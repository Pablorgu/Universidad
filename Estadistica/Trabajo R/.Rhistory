q
datos <- c(1,2,3,2,3,2,1,1,2,2,3,4)
datos <- c(1, 2, 3, 2, 3, 2, 1, 1, 2, 2, 3, 4)
datos <- c(1, 2, 3, 2, 3, 2, 1, 1, 2, 2, 3, 4)
table(datos)
hist(datos)
mean(datos)
hist(datos)
mean(datosM)
mean(datosM)
datosM <- c(1, 2, 3, 2, 3, 2, 111, 1, 2, 2, 3, 4)
mean(datosM)
datosM <- c(1, 2, 3, 2, 3, 2, 11, 1, 2, 2, 3, 4)
mean(datosM)
length(datos)
sort(datos)
median(datosM)
median(datos)
quantile(datos)
data <- read.csv("C:\Users\pablo\Downloads\dfMEC.csv")
data <- read.csv("/Users/pablo/Downloads/dfMEC.csv")
view(data)
View(data)
dfMec$edad
dfdata$edad
data$notaFinal
quantile(data$edad)
sort(data$notaFinal)
quentile(data$edad)(75)-quentile(data$edad)(25)
quantile(data$edad)(75)-quantile(data$edad)(25)
quantile(data$edad, c(.75))-quantile(data$edad, c(.25))
plot(data$notaFinal, data$edad)
table(dfMec$edad)
table(data$edad)
num(data)
lenght(data)
length(data)
count.fields(data)
table(dfMec$edad)
quantile(data$edad, c(.75)) - quantile(data$edad, c(.25))
data$edad - mEdad
mEdad<- mean(data$edad)
data$edad - mEdad
vEdad <- mean((data$edad - mEdad) **2)
vEdad
dEdad <- sqrt(vEdad)
dEdad
Varianzaedad <- mean(data$edad^2) - mean(data$edad)^2
sd(data$edad) * sqrt(199/200)
dfl
df1$notaFinal
covXY/varX
covXY / varX
# Calculamos covarianza y varianzas manualmente
covXY <- mean(df1$notaFinal * df1$notaBach) - mean(df1$notaFinal) * mean(df1$notaBach)
library(tidyverse)
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('c:/data/dfMec.csv')
# Extraemos un nuevo tibble con las variables que vamos a trabajar.
# NO es necesario y normalmente no se haría, pero aquí lo hacemos por claridad.
df1 <- dfMec %>% select(notaFinal, notaBach)
# Calculamos covarianza y varianzas manualmente
covXY <- mean(df1$notaFinal * df1$notaBach) - mean(df1$notaFinal) * mean(df1$notaBach)
varX  <- mean(df1$notaBach ^ 2) - mean(df1$notaBach) ^ 2
varY  <- mean(df1$notaFinal ^ 2) - mean(df1$notaFinal) ^ 2
# Esta es la pendiente de la recta calculada directamente
covXY / varX
# Y este es el centro de gravedad de la distribución, por la que pasa la recta
mean(df1$notaFinal)
mean(df1$notaBach)
# Aquí calculamos el termino independiente o Intercept
mean(df1$notaFinal) - covXY / varX * mean(df1$notaBach)
# coef corr lineal de Pearson r
covXY / sqrt(varX * varY)
# coef corr lineal de Pearson r^2
covXY ^ 2 / varX / varY
# Ahora lo calculamos con lm
mod <- lm(notaFinal ~ notaBach, dfMec)
# Extraemos los coeficientes y el coeficiente de determinación
mod$coefficients
summary(mod)$r.squared
# Vemos que efectivamente los datos se parecen poco a una recta
plot(df1$notaBach, df1$notaFinal)
abline(mod)
# Aquí podemos ver como nuestro modelo lineal predice los datos
df1$notaPredicha <- predict.lm(mod)
# Esto es un tibble con los datos predichos y el error cometido
df1 %>%
mutate(notaPredicha=predict.lm(mod), err=notaFinal - notaPredicha)
# Aquí sumarizamos el MSE, la varianza de la variable predicha y el coeficiente de determinación R2:
df1 %>%
mutate(notaPredicha=predict.lm(mod), err=notaFinal - notaPredicha) %>%
summarise(MSE=mean(err ^ 2), varY=mean(notaFinal ^ 2) - mean(notaFinal) ^ 2, R2=1 - MSE / varY )
# Vemos que el ajuste ordinario por minimos cuadrados el coeficiente de determinación (R^2) coincide con
# Vemos que el ajuste ordinario por minimos cuadrados el coeficiente de determinación (R^2) coincide con
df1$notaFinal
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('c:/data/dfMec.csv')
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('"C:/Users/pablo/Downloads/dfMEC.csv"')
library(tidyverse)
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('"C:/Users/pablo/Downloads/dfMEC.csv"')
# Extraemos un nuevo tibble con las variables que vamos a trabajar.
# NO es necesario y normalmente no se haría, pero aquí lo hacemos por claridad.
df1 <- dfMec %>% select(notaFinal, notaBach)
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('"C:/Users/pablo/Downloads/dfMEC.csv"')
setwd("~/")
setwd("~/")
library(readr)
dfMEC <- read_csv("R/datos/dfMEC.csv")
View(dfMEC)
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('C:/Users/pablo/Documents/R/datos/dfMEC.csv')
# Extraemos un nuevo tibble con las variables que vamos a trabajar.
# NO es necesario y normalmente no se haría, pero aquí lo hacemos por claridad.
df1 <- dfMec %>% select(notaFinal, notaBach)
# Calculamos covarianza y varianzas manualmente
covXY <- mean(df1$notaFinal * df1$notaBach) - mean(df1$notaFinal) * mean(df1$notaBach)
varX  <- mean(df1$notaBach ^ 2) - mean(df1$notaBach) ^ 2
varY  <- mean(df1$notaFinal ^ 2) - mean(df1$notaFinal) ^ 2
# Esta es la pendiente de la recta calculada directamente
covXY / varX
# Y este es el centro de gravedad de la distribución, por la que pasa la recta
mean(df1$notaFinal)
mean(df1$notaBach)
# Aquí calculamos el termino independiente o Intercept
mean(df1$notaFinal) - covXY / varX * mean(df1$notaBach)
# coef corr lineal de Pearson r
covXY / sqrt(varX * varY)
# coef corr lineal de Pearson r^2
covXY ^ 2 / varX / varY
# Ahora lo calculamos con lm
mod <- lm(notaFinal ~ notaBach, dfMec)
# Extraemos los coeficientes y el coeficiente de determinación
mod$coefficients
summary(mod)$r.squared
# Vemos que efectivamente los datos se parecen poco a una recta
plot(df1$notaBach, df1$notaFinal)
# Esta es la pendiente de la recta calculada directamente
covXY / varX
df1$notaFinal - predict.lm(mod)
(df1$notaFinal - predict.lm(mod))^2
(df1$notaFinal - predict.lm(mod))**2
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('c:/data/dfMec.csv')
# Creamos las matrices para las ecuaciones normales
M <- dfMec %>% transmute(x0=1, x1=notaBach, x2=notaSel) %>% as.matrix
Y <- matrix(dfMec$notaFinal)
A <- t(M) %*% M
B <- t(M) %*% Y
# Resolvemos el sistema para obtener los coeficientes de la regesión lineal
solve(A, B)
# Hacemos lo mismo con la función lm
mod <- lm(notaFinal ~ notaBach + notaSel, dfMec)
summary(mod)
# Estas son las predicciones del modelo
predict.lm(mod)
# Cálculo del coeficiente de determinación
dfMec %>%
summarise(MSE = mean((notaFinal - predict.lm(mod)) ^ 2), varY = mean(notaFinal ^ 2) - mean(notaFinal) ^ 2, R2 = 1 - MSE / varY)
# Un modelo con más variables predictoras
mod2 <- lm(notaFinal ~ notaBach + notaSel + minutTeor + minutPrac, dfMec)
summary(mod2)
# Un modelo sin Intercept o término independiente
mod0 <- lm(notaFinal ~ 0 + notaBach + notaSel, dfMec)
mod0
library(tidyverse)
# Cargamos nuestro Tibble utilizando read_csv de Tidyverse
dfMec <- read_csv('C:/Users/pablo/Documents/R/datos/dfMEC.csv')
# Creamos las matrices para las ecuaciones normales
M <- dfMec %>% transmute(x0=1, x1=notaBach, x2=notaSel) %>% as.matrix
Y <- matrix(dfMec$notaFinal)
A <- t(M) %*% M
B <- t(M) %*% Y
# Resolvemos el sistema para obtener los coeficientes de la regesión lineal
solve(A, B)
# Hacemos lo mismo con la función lm
mod <- lm(notaFinal ~ notaBach + notaSel, dfMec)
summary(mod)
# Estas son las predicciones del modelo
predict.lm(mod)
# Cálculo del coeficiente de determinación
dfMec %>%
summarise(MSE = mean((notaFinal - predict.lm(mod)) ^ 2), varY = mean(notaFinal ^ 2) - mean(notaFinal) ^ 2, R2 = 1 - MSE / varY)
# Un modelo con más variables predictoras
mod2 <- lm(notaFinal ~ notaBach + notaSel + minutTeor + minutPrac, dfMec)
summary(mod2)
# Un modelo sin Intercept o término independiente
mod0 <- lm(notaFinal ~ 0 + notaBach + notaSel, dfMec)
mod0
View(A)
setwd("C:/Users/pablo/Desktop/Universidad/Estadistica/Trabajo R")
library(readr)
datos <- read.csv("18608.csv")
View(datos)
View(datos)
library(readr)
datos <- read_csv("18608.csv")
View(datos)
View(datos)
View(datos)
View(datos)
